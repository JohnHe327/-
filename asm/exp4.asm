;编写一个程序，使用子程序调用的方式计算n! 
;n的值通过键盘输入
;n的范围(0,20)
;程序设计中请注意运算结果的范围

DATAS SEGMENT
	NewLine DB 13,10,'$'
	TEN DW 10

	BUFFin DB 100 DUP(?)
	BUFFout DB 100 DUP(?)
	TEMP DW ?
	RE0 DW 0
	RE1 DW 0
	RE2 DW 0
	RE3 DW 0
DATAS  ENDS

STACKS SEGMENT STACK
	DW 100 DUP (0)
STACKS ENDS

CODES  SEGMENT
	ASSUME	CS:CODES, DS:DATAS

FACT PROC NEAR
	.IF BX == 0
		MOV AX, 1
		MOV RE0, 1
		MOV RE1, 0
		MOV RE2, 0
		MOV RE3, 0
		RET
	.ELSE
		PUSH BX
		DEC BX
		CALL FACT
		POP BX

		MOV AX, RE0
		MUL BX 		;RE0×BX=DX:AX
		MOV RE0, AX 	;store AX to RE0
		MOV CX, DX	;store DX to CX

		MOV AX, RE1
		MUL BX		;RE1×BX=DX:AX
		ADD AX, CX
		MOV RE1, AX	;store RE1
		JC CARRY1
		JMP CTN1
CARRY1:		INC DX
CTN1:		MOV CX, DX	;store CX

		MOV AX, RE2
		MUL BX
		ADD AX, CX
		MOV RE2, AX
		JC CARRY2
		JMP CTN2
CARRY2:		INC DX
CTN2:		MOV CX, DX

		MOV AX, RE3
		MUL BX
		ADD AX, CX
		MOV RE3, AX
		RET
	.ENDIF
FACT ENDP

START:
	MOV AX, DATAS
	MOV DS, AX

;input string
	MOV AX, DATAS
	MOV ES, AX
	CLD
	LEA DI, BUFFin
	MOV CX, 0
	MOV AH, 01H
	INT 21H
	.WHILE AL >= 30H && AL <= 39H
		STOSB
		INC CX
		MOV AH, 01H
		INT 21H
	.ENDW
	MOV AL, '$'
	STOSB

;string to number
	LEA SI, BUFFin
	MOV TEMP, 0
	MOV DL, [SI]		;DL=lookahead
	.WHILE DL != '$'
		MOV AX, TEMP
		MUL TEN
		MOV TEMP, AX
		MOV DL, [SI]
		SUB DL, 30H
		MOV DH, 0
		ADD TEMP, DX
		INC SI
		MOV DL, [SI]
	.ENDW

;fact
	MOV BX, TEMP
	CALL FACT

;print to bufferout
	LEA DI, BUFFout
;RE3
	MOV AX, RE3
	MOV CL, 12
	SHR AX, CL
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE3
	MOV CL, 8
	SHR AX, CL
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE3
	MOV CL, 4
	SHR AX, CL
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE3
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

;RE2
	MOV AX, RE2
	MOV CL, 12
	SHR AX, CL
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE2
	MOV CL, 8
	SHR AX, CL
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE2
	MOV CL, 4
	SHR AX, CL
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE2
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

;RE1
	MOV AX, RE1
	MOV CL, 12
	SHR AX, CL
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE1
	MOV CL, 8
	SHR AX, CL
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE1
	MOV CL, 4
	SHR AX, CL
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE1
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

;RE0
	MOV AX, RE0
	MOV CL, 12
	SHR AX, CL
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE0
	MOV CL, 8
	SHR AX, CL
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE0
	MOV CL, 4
	SHR AX, CL
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF

	MOV AX, RE0
	AND AX, 0FH
	.IF AL <= 9
		ADD AL, 30H
		MOV [DI], AL
		INC DI
	.ELSE
		ADD AL, 37H
		MOV [DI], AL
		INC DI
	.ENDIF


	MOV BYTE PTR [DI], '$'
	INC DI

;print
	LEA DI, BUFFout
	MOV AL, [DI]
	.WHILE AL == '0'		;skip 0
		INC DI
		MOV AL, [DI]
	.ENDW
	MOV DX, DI
	MOV AH, 09H
	INT 21H

	MOV DL, BYTE PTR 'H'
	MOV AH, 02H
	INT 21H

;new line
	LEA DX, NewLine
	MOV AH, 09H
	INT 21H

;exit
STOP:	MOV  AX, 4C00H
	INT  21H
CODES  ENDS
END   START
